<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>node.js - Documentation</title>

    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="https://code.ionicframework.com/ionicons/2.0.1/css/ionicons.min.css">
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav>
    <li class="nav-link nav-home-link"><a href="index.html">Home</a></li><li class="nav-heading">Classes</li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="node-html-light.Attributes.html">Attributes</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="node-html-light.Attributes.html#.of">of</a></span></li><li class="nav-heading"><span class="nav-item-type type-class">C</span><span class="nav-item-name"><a href="node-html-light.Text.html">Text</a></span></li><li class="nav-item"><span class="nav-item-type type-function">F</span><span class="nav-item-name"><a href="node-html-light.Text.html#.of">of</a></span></li><li class="nav-heading">Namespaces</li><li class="nav-heading"><span class="nav-item-type type-namespace">N</span><span class="nav-item-name"><a href="node-html-light.html">node-html-light</a></span></li>
</nav>

<div id="main">
    
    <h1 class="page-title">node.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict'

const htmlParser = require('htmlparser2')
const domUtils = htmlParser.DomUtils
const fs = require('fs')

/**
 * @class
 * @memberof node-html-light
 */
class Node {

    /** */
    static get TYPE_COMMENT() {
        return 'comment'
    }
    /** */
    static get TYPE_TAG() {
        return 'tag'
    }
    /** */
    static get TYPE_TEXT() {
        return 'text'
    }
    /** */
    static get TYPE_SCRIPT() {
        return 'script'
    }

    /**
    * Creates a new document of a files contents
    * @param {string} path path to a file
    * @returns {Node} a new document
    */
    static fromPath(path) {
        return new Promise((resolve, reject) => {
            fs.readFile(path, { encoding: 'utf-8' }, (error, data) => {
                if (error) {
                    reject(error)
                } else {
                    const node = Node.fromString(data)
                    resolve(node)
                }
            })
        })
    }

    /**
     * Parses a html string into a node object
     * @param {string} string a html string
     * @returns {Node} a new Node
     */
    static fromString(string) {

        const parsed = htmlParser.parseDOM(string)

        if (parsed.length > 1) {

            return parsed.map(string => new Node(string))
        } else if (parsed.length === 1) {

            return new Node(parsed[0])
        }

        return new Node(parsed)
    }

    /**
     * Creates a new Node with name and attributes
     * @param {string|Object} tag the nodes name or a pojo that will be wrapped
     * @param {Array.&lt;Attribute>} [attrs=empty] attrs an array of attributes
     * @returns {Node} a new Node
     */
    static of(tag, attrs) {

        if (tag instanceof Node) {
            return tag
        } else if (typeof tag === 'object') {
            return new Node(tag, attrs)
        }

        const node = {
            name: tag,
            children: [],
            attribs: {}
        }

        switch (tag) {
            case Node.TYPE_SCRIPT: {
                node.type = Node.TYPE_SCRIPT
                break
            }

            default: {
                node.type = Node.TYPE_TAG
                break
            }
        }

        return new Node(node, attrs)
    }

    /**
     * @constructor
     * @private
     * @description &lt;b>Do not use this method directly. Use one of the static helper methods instead.&lt;/b>
     * @param {Object} elem object containing the nodes properties
     * @param {Array&lt;Attribute>} [attrs=empty] attrs an array of attributes
     * @returns {Node} a new Node
     */
    constructor(elem, attrs) {
        this._element = elem

        if (attrs) {
            /* istanbul ignore else */
            if (!this._element.attribs) {
                this._element.attribs = {}
            }

            attrs.forEach((attr) => {
                this._element.attribs[attr.key] = attr.value
            })
        }
    }

    /**
     * Returns the raw representation of this node
     * @private
     * @deprecated
     * @returns {Object} htmlparser2's representation of a html node
     */
    get() {
        return this._element
    }

    /**
     * Returns the name of this node
     * @returns {string}
     */
    get name() {
        return this.get().name
    }


    /**
     * Returns the type of this node
     * @see node-html-light.Node.TYPE_COMMENT
     * @see node-html-light.Node.TYPE_TAG
     * @see node-html-light.Node.TYPE_TEXT
     * @returns {string}
     */
    get type() {
        return this.get().type
    }

    /**
     * Returns the parent node of this node
     * @returns {Node}
     */
    get parent() {
        return this._wrapOrNull(this.get().parent)
    }

    /**
     * Returns the previous sibling of the current node
     * @returns {Node}
     */
    get previousSibling() {
        let previous = this.get().previousSibling
        while (previous &amp;&amp; previous.type !== Node.TYPE_TAG) {
            previous = previous.previousSibling
        }
        return this._wrapOrNull(previous)
    }

     /**
     * Returns the next sibling of the current node
     * @returns {Node}
     */
    get nextSibling() {
        let next = this.get().next
        while (next &amp;&amp; next.type !== Node.TYPE_TAG) {
            next = next.next
        }
        return this._wrapOrNull(next)
    }

    /**
     * @private
     */
    _wrapOrNull(rawElement) {
        if (rawElement) {
            return new Node(rawElement)
        }

        return null
    }

    /**
       * Returns all attributes of this node. The returned object is live, so you can add or remove attributes as you wish
       * @returns {Object}
       */
    get attributes() {
        return this.get().attribs
    }

    /**
      * Returns an array of nodes matching tag name and attributes
      * @param {Object} element an object whos properties reflect the properties of the element we are looking for
      * @param {Array&lt;Attribute>} [attrs=empty] attrs an array of attributes
      * @param {Number} [limit=Infinity] limit the max number of results
      * @returns {Array&lt;Node>}
      */
    find(element, attrs, limit) {

        if (typeof element === 'string') {
            const name = element
            const type = name === Node.TYPE_SCRIPT ? Node.TYPE_SCRIPT : Node.TYPE_TAG

            element = {
                type, name
            }
        }

        const elements = domUtils.filter((el) => {
            let found = true

            found = Object.keys(element).every((key) => el[key] === element[key])

            if (found &amp;&amp; attrs) {
                found = attrs.find((attr) => {
                    return el.attribs[attr.key] === attr.value
                })
            }

            return found
        }, this._element, true, limit)

        return elements.map((el) => new Node(el))
    }

    /**
      * Search a node and its children for nodes passing a test function.
      * @param {Node} node the root node
      * @param {Number} [limit=Infinity] limit the max number of results
      * @returns {Array&lt;Node>}
    */
    filter(callback, limit = Infinity) {
        return domUtils.filter(callback, this._element, true, limit).map(el => new Node(el))
    }

    /**
      * Removes a child node
      * @param {Node|Array&lt;Node>} child the child node to remove
      * @returns {this}
      */
    removeChild(child) {
        if (Array.isArray(child)) {
            child.forEach(element => domUtils.removeElement(element.get()))
        } else {
            domUtils.removeElement(child.get())
        }
    }

    /**
      * Appends a node to this node's children
      * @param {Node} newChild the node to be appended
      */
    appendChild(newChild) {
        domUtils.appendChild(this._element, newChild.get())
    }

    /**
      * Insert a new child element before an existing child
      * @param {Node} newChild the new Child to be inserted
      * @param {Node} existingChild the existing Child
      */
    appendChildBefore(newChild, existingChild) {
        domUtils.prepend(existingChild.get(), newChild.get())
    }

    /**
      * Insert a new child element after an existing child
      * @param {Node} newChild the new Child to be inserted
      * @param {Node} existingChild the existing Child
      */
    appendChildAfter(newChild, existingChild) {
        domUtils.append(existingChild.get(), newChild.get())
    }

    /**
      * Replaces a child element with a new child
      * @param {Node} newChild the new Child
      * @param {Node} existingChild the existing Child to be replaced
      */
    replaceChild(newChild, existingChild) {
        domUtils.replaceElement(existingChild.get(), newChild.get())
    }

    /**
    * Returns the stringified version of this document
    * @returns {string} 
    */
    toHtml() {
        return domUtils.getOuterHTML(this._element)
    }
}

module.exports = Node</code></pre>
        </article>
    </section>




</div>

<br class="clear">

<footer>
    Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.6.7</a> using the Minami theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/linenumber.js"></script>
</body>
</html>
